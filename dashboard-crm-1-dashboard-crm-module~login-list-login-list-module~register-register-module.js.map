{"version":3,"sources":["webpack:///./node_modules/@angular/cdk/esm5/drag-drop.es5.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACkS;AAC/Q;AACqB;AACH;AACZ;AACD;AACE;AACJ;;AAEtB;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA,SAAS,EAAE;AACX,0HAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,oGAAoG,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,kCAAkC,EAAE,+BAA+B;AAC5H,+BAA+B,wBAAwB,gCAAgC,EAAE,EAAE;AAC3F;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yEAAyE,2BAA2B,EAAE;AACtG;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,yDAAyD,uCAAuC,EAAE;AAClG,yDAAyD,4CAA4C,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS,yEAA2B,qBAAqB,IAAI;AAC7D;AACA;AACA,mDAAmD;AACnD,SAAS,6DAAe;AACxB,SAAS,gCAAgC,gIAAkC;AAC3E,MAAM;AACN,kIAA4E,+CAA+C,yQAA+D,EAAE,+CAA+C;AAC3O;AACA,CAAC;;AAED;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,gDAAgD;AAChD,SAAS;AACT,MAAM;AACN;AACA,CAAC;;AAED;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,qDAAqD;AACrD,SAAS;AACT,MAAM;AACN;AACA,gBAAgB,4DAAc;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,iDAAiD;AACjD,SAAS;AACT,MAAM;AACN;AACA,gBAAgB,4DAAc;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA,SAAS,EAAE;AACX;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,+BAA+B,EAAE;AACjC;AACA,+BAA+B,EAAE;AACjC;AACA,0FAA0F,EAAE;AAC5F,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,aAAa;AACpF;AACA,uBAAuB,EAAE;AACzB;AACA,4CAA4C;AAC5C,2DAA2D;AAC3D;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA,4DAA4D,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B,gBAAgB,EAAE,EAAE;AAC7F;AACA;AACA,mEAAmE,sCAAsC,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA;AACA,oCAAoC,uCAAuC;AAC3E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,2BAA2B,EAAE;AAC7B;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,EAAE;AAChE;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,0CAA0C;AAC1C,SAAS,iEAAmB;AAC5B,SAAS,gCAAgC,0FAA4C,GAAG,+DAAiB,GAAG,+DAAiB,GAAG;AAChI,SAAS,gCAAgC,gIAAkC,GAAG;AAC9E,SAAS,6DAAe;AACxB,SAAS,uEAAyB;AAClC,SAAS,6EAAsB;AAC/B,SAAS,yBAAyB;AAClC,SAAS,uFAAqC,+DAAiB;AAC/D,MAAM;AACN;AACA,oBAAoB,8FAAgD;AACpE,4BAA4B,4FAA8C;AAC1E,gCAAgC,gGAAkD;AAClF,gBAAgB,oFAAsC;AACtD,oBAAoB,wFAA0C;AAC9D,+BAA+B,2FAA6C;AAC5E,mBAAmB,wFAA0C;AAC7D,iBAAiB,sFAAwC;AACzD,mBAAmB,wFAA0C;AAC7D,kBAAkB,uFAAyC;AAC3D,mBAAmB,wFAA0C;AAC7D,iBAAiB,sFAAwC;AACzD;AACA;AACA,CAAC;AACD;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC,iCAAiC,EAAE;AACnC,6BAA6B,EAAE,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB,EAAE;AAClD;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,gEAAgE,YAAY,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,yEAAyE,kCAAkC,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,uEAAuE,kCAAkC,EAAE;AAC3G,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC,4CAA4C,EAAE;AACjF;AACA,kCAAkC,8CAA8C,EAAE,8DAA8D,EAAE;AAClJ,qCAAqC,+BAA+B,EAAE;AACtE,kCAAkC,UAAU,6EAA6E,EAAE,EAAE;AAC7H;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,wDAAwD,mDAAmD,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS,wEAA0B;AACnC;AACA;AACA;AACA;AACA,gDAAgD,eAAe,MAAM,OAAO,aAAa,2BAA2B,kBAAkB,uBAAuB,wCAAwC,yBAAyB,sBAAsB,qBAAqB,iBAAiB;AAC1R;AACA,yBAAyB,oDAAoD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,0CAA0C;AAC1C,SAAS,iEAAmB;AAC5B,SAAS;AACT,MAAM;AACN;AACA,uBAAuB,2JAAuD,gBAAgB,EAAE,KAAK;AACrG,uBAAuB,4DAAc;AACrC,gBAAgB,4DAAc;AAC9B,uBAAuB,4DAAc;AACrC,cAAc,4DAAc;AAC5B,oBAAoB,4DAAc;AAClC,0BAA0B,4DAAc;AACxC,mBAAmB,6DAAe;AAClC,mBAAmB,6DAAe;AAClC,kBAAkB,6DAAe;AACjC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,oCAAoC;AAClD;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;;AAEQ;AACR","file":"dashboard-crm-1-dashboard-crm-module~login-list-login-list-module~register-register-module.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgZone, Inject, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, forwardRef, Input, Output, ViewEncapsulation, ContentChild, Directive, Optional, SkipSelf, ViewContainerRef, TemplateRef, InjectionToken, NgModule, defineInjectable, inject } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { Subject, merge, Observable } from 'rxjs';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { takeUntil, take } from 'rxjs/operators';\nimport { coerceArray } from '@angular/cdk/coercion';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Event options that can be used to bind an active event.\n  @type {?} */\nvar activeEventOptions = supportsPassiveEventListeners() ? { passive: false } : false;\n// unsupported: template constraints.\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\nvar DragDropRegistry = /** @class */ (function () {\n    function DragDropRegistry(_ngZone, _document) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Listener used to prevent `touchmove` events while the element is being dragged.\n         * This gets bound once, ahead of time, because WebKit won't preventDefault on a\n         * dynamically-added `touchmove` listener. See https://bugs.webkit.org/show_bug.cgi?id=184250.\n         */\n        this._preventScrollListener = function (event) {\n            if (_this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        };\n        this._document = _document;\n    }\n    /** Adds a drop container to the registry. */\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    DragDropRegistry.prototype.registerDropContainer = /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    function (drop) {\n        if (!this._dropInstances.has(drop)) {\n            if (this.getDropContainer(drop.id)) {\n                throw Error(\"Drop instance with id \\\"\" + drop.id + \"\\\" has already been registered.\");\n            }\n            this._dropInstances.add(drop);\n        }\n    };\n    /** Adds a drag item instance to the registry. */\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.registerDragItem = /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        var _this = this;\n        this._dragInstances.add(drag);\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular(function () {\n                // The event handler has to be explicitly active, because\n                // newer browsers make it passive by default.\n                // The event handler has to be explicitly active, because\n                // newer browsers make it passive by default.\n                _this._document.addEventListener('touchmove', _this._preventScrollListener, activeEventOptions);\n            });\n        }\n    };\n    /** Removes a drop container from the registry. */\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    DragDropRegistry.prototype.removeDropContainer = /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    function (drop) {\n        this._dropInstances.delete(drop);\n    };\n    /** Removes a drag item instance from the registry. */\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.removeDragItem = /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventScrollListener, /** @type {?} */ (activeEventOptions));\n        }\n    };\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param drag Drag instance which is being dragged.\n     * @param event Event that initiated the dragging.\n     */\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    DragDropRegistry.prototype.startDragging = /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    function (drag, event) {\n        var _this = this;\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            var isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            var moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            var upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, { handler: function (e) { return _this.pointerMove.next(e); }, options: activeEventOptions })\n                .set(upEvent, { handler: function (e) { return _this.pointerUp.next(e); } })\n                .forEach(function (config, name) {\n                _this._ngZone.runOutsideAngular(function () {\n                    _this._document.addEventListener(name, config.handler, config.options);\n                });\n            });\n        }\n    };\n    /** Stops dragging a drag item instance. */\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.stopDragging = /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    };\n    /** Gets whether a drag item instance is currently being dragged. */\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.isDragging = /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        return this._activeDragInstances.has(drag);\n    };\n    /** Gets a drop container by its id. */\n    /**\n     * Gets a drop container by its id.\n     * @param {?} id\n     * @return {?}\n     */\n    DragDropRegistry.prototype.getDropContainer = /**\n     * Gets a drop container by its id.\n     * @param {?} id\n     * @return {?}\n     */\n    function (id) {\n        return Array.from(this._dropInstances).find(function (instance) { return instance.id === id; });\n    };\n    /**\n     * @return {?}\n     */\n    DragDropRegistry.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._dragInstances.forEach(function (instance) { return _this.removeDragItem(instance); });\n        this._dropInstances.forEach(function (instance) { return _this.removeDropContainer(instance); });\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    };\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @return {?}\n     */\n    DragDropRegistry.prototype._clearGlobalListeners = /**\n     * Clears out the global event listeners from the `document`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalListeners.forEach(function (config, name) {\n            _this._document.removeEventListener(name, config.handler, config.options);\n        });\n        this._globalListeners.clear();\n    };\n    DragDropRegistry.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    DragDropRegistry.ctorParameters = function () { return [\n        { type: NgZone },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    /** @nocollapse */ DragDropRegistry.ngInjectableDef = defineInjectable({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(inject(NgZone), inject(DOCUMENT)); }, token: DragDropRegistry, providedIn: \"root\" });\n    return DragDropRegistry;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nvar CdkDragHandle = /** @class */ (function () {\n    function CdkDragHandle(element) {\n        this.element = element;\n    }\n    CdkDragHandle.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkDragHandle]',\n                    host: {\n                        'class': 'cdk-drag-handle'\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDragHandle.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    return CdkDragHandle;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nvar CdkDragPlaceholder = /** @class */ (function () {\n    function CdkDragPlaceholder(templateRef) {\n        this.templateRef = templateRef;\n    }\n    CdkDragPlaceholder.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[cdkDragPlaceholder]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDragPlaceholder.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    CdkDragPlaceholder.propDecorators = {\n        data: [{ type: Input }]\n    };\n    return CdkDragPlaceholder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nvar CdkDragPreview = /** @class */ (function () {\n    function CdkDragPreview(templateRef) {\n        this.templateRef = templateRef;\n    }\n    CdkDragPreview.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[cdkDragPreview]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDragPreview.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    CdkDragPreview.propDecorators = {\n        data: [{ type: Input }]\n    };\n    return CdkDragPreview;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token that is used to provide a CdkDrop instance to CdkDrag.\n * Used for avoiding circular imports.\n  @type {?} */\nvar CDK_DROP_CONTAINER = new InjectionToken('CDK_DROP_CONTAINER');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Amount the pixels the user should drag before we\n * consider them to have changed the drag direction.\n  @type {?} */\nvar POINTER_DIRECTION_CHANGE_THRESHOLD = 5;\n/**\n * Element that can be moved inside a CdkDrop container.\n * @template T\n */\nvar CdkDrag = /** @class */ (function () {\n    function CdkDrag(element, /** Droppable container that the draggable is a part of. */\n    dropContainer, document, _ngZone, _viewContainerRef, _viewportRuler, _dragDropRegistry, _dir) {\n        var _this = this;\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        this._dir = _dir;\n        this._destroyed = new Subject();\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Whether the element has moved since the user started dragging it.\n         */\n        this._hasMoved = false;\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new Subject();\n        /**\n         * Amount of subscriptions to the move event. Used to avoid\n         * hitting the zone if the consumer didn't subscribe to it.\n         */\n        this._moveEventSubscriptions = 0;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new EventEmitter();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new EventEmitter();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = Observable.create(function (observer) {\n            /** @type {?} */\n            var subscription = _this._moveEvents.subscribe(observer);\n            _this._moveEventSubscriptions++;\n            return function () {\n                subscription.unsubscribe();\n                _this._moveEventSubscriptions--;\n            };\n        });\n        /**\n         * Starts the dragging sequence.\n         */\n        this._startDragging = function (event) {\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (_this._handles.length) {\n                /** @type {?} */\n                var targetHandle = _this._handles.find(function (handle) {\n                    /** @type {?} */\n                    var element = handle.element.nativeElement;\n                    /** @type {?} */\n                    var target = event.target;\n                    return !!target && (target === element || element.contains(/** @type {?} */ (target)));\n                });\n                if (targetHandle) {\n                    _this._pointerDown(targetHandle.element.nativeElement, event);\n                }\n            }\n            else {\n                _this._pointerDown(_this._rootElement, event);\n            }\n        };\n        /**\n         * Handler for when the pointer is pressed down on the element or the handle.\n         */\n        this._pointerDown = function (referenceElement, event) {\n            /** @type {?} */\n            var isDragging = _this._isDragging();\n            // Abort if the user is already dragging or is using a mouse button other than the primary one.\n            if (isDragging || (!_this._isTouchEvent(event) && event.button !== 0)) {\n                return;\n            }\n            /** @type {?} */\n            var endedOrDestroyed = merge(_this.ended, _this._destroyed);\n            _this._dragDropRegistry.pointerMove\n                .pipe(takeUntil(endedOrDestroyed))\n                .subscribe(_this._pointerMove);\n            _this._dragDropRegistry.pointerUp\n                .pipe(takeUntil(endedOrDestroyed))\n                .subscribe(_this._pointerUp);\n            _this._dragDropRegistry.startDragging(_this, event);\n            _this._initialContainer = _this.dropContainer;\n            _this._scrollPosition = _this._viewportRuler.getViewportScrollPosition();\n            // If we have a custom preview template, the element won't be visible anyway so we avoid the\n            // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n            // If we have a custom preview template, the element won't be visible anyway so we avoid the\n            // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n            _this._pickupPositionInElement = _this._previewTemplate ? { x: 0, y: 0 } :\n                _this._getPointerPositionInElement(referenceElement, event);\n            /** @type {?} */\n            var pointerPosition = _this._pickupPositionOnPage = _this._getPointerPositionOnPage(event);\n            _this._pointerDirectionDelta = { x: 0, y: 0 };\n            _this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n            // Emit the event on the item before the one on the container.\n            // Emit the event on the item before the one on the container.\n            _this.started.emit({ source: _this });\n            if (_this.dropContainer) {\n                /** @type {?} */\n                var element = _this._rootElement;\n                // Grab the `nextSibling` before the preview and placeholder\n                // have been created so we don't get the preview by accident.\n                // Grab the `nextSibling` before the preview and placeholder\n                // have been created so we don't get the preview by accident.\n                _this._nextSibling = element.nextSibling;\n                /** @type {?} */\n                var preview = _this._preview = _this._createPreviewElement();\n                /** @type {?} */\n                var placeholder = _this._placeholder = _this._createPlaceholderElement();\n                // We move the element out at the end of the body and we make it hidden, because keeping it in\n                // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n                // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n                element.style.display = 'none';\n                _this._document.body.appendChild(/** @type {?} */ ((element.parentNode)).replaceChild(placeholder, element));\n                _this._document.body.appendChild(preview);\n                _this.dropContainer.start();\n            }\n        };\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = function (event) {\n            // TODO(crisbeto): this should start dragging after a certain threshold,\n            // otherwise we risk interfering with clicks on the element.\n            if (!_this._isDragging()) {\n                return;\n            }\n            _this._hasMoved = true;\n            event.preventDefault();\n            /** @type {?} */\n            var pointerPosition = _this._getConstrainedPointerPosition(event);\n            _this._updatePointerDirectionDelta(pointerPosition);\n            if (_this.dropContainer) {\n                _this._updateActiveDropContainer(pointerPosition);\n            }\n            else {\n                /** @type {?} */\n                var activeTransform = _this._activeTransform;\n                activeTransform.x =\n                    pointerPosition.x - _this._pickupPositionOnPage.x + _this._passiveTransform.x;\n                activeTransform.y =\n                    pointerPosition.y - _this._pickupPositionOnPage.y + _this._passiveTransform.y;\n                _this._setTransform(_this._rootElement, activeTransform.x, activeTransform.y);\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone becaus we run all of the events on the outside.\n            if (_this._moveEventSubscriptions > 0) {\n                _this._ngZone.run(function () {\n                    _this._moveEvents.next({\n                        source: _this,\n                        pointerPosition: pointerPosition,\n                        event: event\n                    });\n                });\n            }\n        };\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = function () {\n            if (!_this._isDragging()) {\n                return;\n            }\n            _this._dragDropRegistry.stopDragging(_this);\n            if (!_this.dropContainer) {\n                // Convert the active transform into a passive one. This means that next time\n                // the user starts dragging the item, its position will be calculated relatively\n                // to the new passive transform.\n                // Convert the active transform into a passive one. This means that next time\n                // the user starts dragging the item, its position will be calculated relatively\n                // to the new passive transform.\n                _this._passiveTransform.x = _this._activeTransform.x;\n                _this._passiveTransform.y = _this._activeTransform.y;\n                _this._ngZone.run(function () { return _this.ended.emit({ source: _this }); });\n                return;\n            }\n            _this._animatePreviewToPlaceholder().then(function () { return _this._cleanupDragArtifacts(); });\n        };\n        this._document = document;\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    CdkDrag.prototype.getPlaceholderElement = /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    function () {\n        return this._placeholder;\n    };\n    /** Returns the root draggable element. */\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    CdkDrag.prototype.getRootElement = /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    function () {\n        return this._rootElement;\n    };\n    /**\n     * @return {?}\n     */\n    CdkDrag.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            /** @type {?} */\n            var rootElement = _this._rootElement = _this._getRootElement();\n            rootElement.addEventListener('mousedown', _this._startDragging);\n            rootElement.addEventListener('touchstart', _this._startDragging);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    CdkDrag.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._rootElement.removeEventListener('mousedown', this._startDragging);\n        this._rootElement.removeEventListener('touchstart', this._startDragging);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this._isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            this._removeElement(this._rootElement);\n        }\n        this._nextSibling = null;\n        this._dragDropRegistry.removeDragItem(this);\n        this._moveEvents.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /** Checks whether the element is currently being dragged. */\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    CdkDrag.prototype._isDragging = /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    function () {\n        return this._dragDropRegistry.isDragging(this);\n    };\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @return {?}\n     */\n    CdkDrag.prototype._cleanupDragArtifacts = /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        if (this._nextSibling) {\n            /** @type {?} */ ((this._nextSibling.parentNode)).insertBefore(this._rootElement, this._nextSibling);\n        }\n        else {\n            /** @type {?} */ ((this._placeholder.parentNode)).appendChild(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run(function () {\n            /** @type {?} */\n            var currentIndex = _this.dropContainer.getItemIndex(_this);\n            _this.ended.emit({ source: _this });\n            _this.dropped.emit({\n                item: _this,\n                currentIndex: currentIndex,\n                previousIndex: _this._initialContainer.getItemIndex(_this),\n                container: _this.dropContainer,\n                previousContainer: _this._initialContainer\n            });\n            _this.dropContainer.drop(_this, currentIndex, _this._initialContainer);\n        });\n    };\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @param {?} __0\n     * @return {?}\n     */\n    CdkDrag.prototype._updateActiveDropContainer = /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @param {?} __0\n     * @return {?}\n     */\n    function (_a) {\n        var _this = this;\n        var x = _a.x, y = _a.y;\n        /** @type {?} */\n        var newContainer = this.dropContainer._getSiblingContainerFromPosition(this, x, y);\n        if (newContainer) {\n            this._ngZone.run(function () {\n                // Notify the old container that the item has left.\n                // Notify the old container that the item has left.\n                _this.exited.emit({ item: _this, container: _this.dropContainer });\n                _this.dropContainer.exit(_this);\n                // Notify the new container that the item has entered.\n                // Notify the new container that the item has entered.\n                _this.entered.emit({ item: _this, container: newContainer });\n                _this.dropContainer = newContainer;\n                _this.dropContainer.enter(_this, x, y);\n            });\n        }\n        this.dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._setTransform(this._preview, x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    };\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @return {?}\n     */\n    CdkDrag.prototype._createPreviewElement = /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var preview;\n        if (this._previewTemplate) {\n            /** @type {?} */\n            var viewRef = this._viewContainerRef.createEmbeddedView(this._previewTemplate.templateRef, this._previewTemplate.data);\n            preview = viewRef.rootNodes[0];\n            this._previewRef = viewRef;\n            this._setTransform(preview, this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            var element = this._rootElement;\n            /** @type {?} */\n            var elementRect = element.getBoundingClientRect();\n            preview = /** @type {?} */ (element.cloneNode(true));\n            preview.style.width = elementRect.width + \"px\";\n            preview.style.height = elementRect.height + \"px\";\n            this._setTransform(preview, elementRect.left, elementRect.top);\n        }\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._dir ? this._dir.value : 'ltr');\n        return preview;\n    };\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @return {?}\n     */\n    CdkDrag.prototype._createPlaceholderElement = /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var placeholder;\n        if (this._placeholderTemplate) {\n            this._placeholderRef = this._viewContainerRef.createEmbeddedView(this._placeholderTemplate.templateRef, this._placeholderTemplate.data);\n            placeholder = this._placeholderRef.rootNodes[0];\n        }\n        else {\n            placeholder = /** @type {?} */ (this._rootElement.cloneNode(true));\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    };\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    CdkDrag.prototype._getPointerPositionInElement = /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    function (referenceElement, event) {\n        /** @type {?} */\n        var elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        var handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        var referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        var x = this._isTouchEvent(event) ?\n            event.targetTouches[0].pageX - referenceRect.left - this._scrollPosition.left :\n            event.offsetX;\n        /** @type {?} */\n        var y = this._isTouchEvent(event) ?\n            event.targetTouches[0].pageY - referenceRect.top - this._scrollPosition.top :\n            event.offsetY;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    };\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    CdkDrag.prototype._animatePreviewToPlaceholder = /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    function () {\n        var _this = this;\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        var placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._setTransform(this._preview, placeholderRect.left, placeholderRect.top);\n        /** @type {?} */\n        var duration = getTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular(function () {\n            return new Promise(function (resolve) {\n                /** @type {?} */\n                var handler = /** @type {?} */ ((function (event) {\n                    if (!event || event.target === _this._preview) {\n                        _this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                }));\n                /** @type {?} */\n                var timeout = setTimeout(handler, duration * 1.5);\n                _this._preview.addEventListener('transitionend', handler);\n            });\n        });\n    };\n    /**\n     * Sets the `transform` style on an element.\n     * @param {?} element Element on which to set the transform.\n     * @param {?} x Desired position of the element along the X axis.\n     * @param {?} y Desired position of the element along the Y axis.\n     * @return {?}\n     */\n    CdkDrag.prototype._setTransform = /**\n     * Sets the `transform` style on an element.\n     * @param {?} element Element on which to set the transform.\n     * @param {?} x Desired position of the element along the X axis.\n     * @param {?} y Desired position of the element along the Y axis.\n     * @return {?}\n     */\n    function (element, x, y) {\n        element.style.transform = \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\n    };\n    /**\n     * Helper to remove an element from the DOM and to do all the necessary null checks.\n     * @param {?} element Element to be removed.\n     * @return {?}\n     */\n    CdkDrag.prototype._removeElement = /**\n     * Helper to remove an element from the DOM and to do all the necessary null checks.\n     * @param {?} element Element to be removed.\n     * @return {?}\n     */\n    function (element) {\n        if (element && element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    };\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @param {?} event\n     * @return {?}\n     */\n    CdkDrag.prototype._getPointerPositionOnPage = /**\n     * Determines the point of the page that was touched by the user.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var point = this._isTouchEvent(event) ? event.touches[0] : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    };\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @param {?} event\n     * @return {?}\n     */\n    CdkDrag.prototype._getConstrainedPointerPosition = /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        var dropContainerLock = this.dropContainer ? this.dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            point.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            point.x = this._pickupPositionOnPage.x;\n        }\n        return point;\n    };\n    /**\n     * Determines whether an event is a touch event.\n     * @param {?} event\n     * @return {?}\n     */\n    CdkDrag.prototype._isTouchEvent = /**\n     * Determines whether an event is a touch event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        return event.type.startsWith('touch');\n    };\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @return {?}\n     */\n    CdkDrag.prototype._destroyPreview = /**\n     * Destroys the preview element and its ViewRef.\n     * @return {?}\n     */\n    function () {\n        if (this._preview) {\n            this._removeElement(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = /** @type {?} */ ((null));\n    };\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @return {?}\n     */\n    CdkDrag.prototype._destroyPlaceholder = /**\n     * Destroys the placeholder element and its ViewRef.\n     * @return {?}\n     */\n    function () {\n        if (this._placeholder) {\n            this._removeElement(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = /** @type {?} */ ((null));\n    };\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    CdkDrag.prototype._updatePointerDirectionDelta = /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    function (pointerPositionOnPage) {\n        var x = pointerPositionOnPage.x, y = pointerPositionOnPage.y;\n        /** @type {?} */\n        var delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        var positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        /** @type {?} */\n        var changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        var changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > POINTER_DIRECTION_CHANGE_THRESHOLD) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > POINTER_DIRECTION_CHANGE_THRESHOLD) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n    };\n    /**\n     * Gets the root draggable element, based on the `rootElementSelector`.\n     * @return {?}\n     */\n    CdkDrag.prototype._getRootElement = /**\n     * Gets the root draggable element, based on the `rootElementSelector`.\n     * @return {?}\n     */\n    function () {\n        if (this.rootElementSelector) {\n            /** @type {?} */\n            var currentElement = /** @type {?} */ (this.element.nativeElement.parentElement);\n            while (currentElement) {\n                if (currentElement.matches(this.rootElementSelector)) {\n                    return currentElement;\n                }\n                currentElement = currentElement.parentElement;\n            }\n        }\n        return this.element.nativeElement;\n    };\n    CdkDrag.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkDrag]',\n                    exportAs: 'cdkDrag',\n                    host: {\n                        'class': 'cdk-drag',\n                        '[class.cdk-drag-dragging]': '_isDragging()',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDrag.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_DROP_CONTAINER,] }, { type: Optional }, { type: SkipSelf }] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n        { type: NgZone },\n        { type: ViewContainerRef },\n        { type: ViewportRuler },\n        { type: DragDropRegistry },\n        { type: Directionality, decorators: [{ type: Optional }] }\n    ]; };\n    CdkDrag.propDecorators = {\n        _handles: [{ type: ContentChildren, args: [CdkDragHandle,] }],\n        _previewTemplate: [{ type: ContentChild, args: [CdkDragPreview,] }],\n        _placeholderTemplate: [{ type: ContentChild, args: [CdkDragPlaceholder,] }],\n        data: [{ type: Input, args: ['cdkDragData',] }],\n        lockAxis: [{ type: Input, args: ['cdkDragLockAxis',] }],\n        rootElementSelector: [{ type: Input, args: ['cdkDragRootElement',] }],\n        started: [{ type: Output, args: ['cdkDragStarted',] }],\n        ended: [{ type: Output, args: ['cdkDragEnded',] }],\n        entered: [{ type: Output, args: ['cdkDragEntered',] }],\n        exited: [{ type: Output, args: ['cdkDragExited',] }],\n        dropped: [{ type: Output, args: ['cdkDragDropped',] }],\n        moved: [{ type: Output, args: ['cdkDragMoved',] }]\n    };\n    return CdkDrag;\n}());\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    /** @type {?} */\n    var multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransitionDurationInMs(element) {\n    /** @type {?} */\n    var computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    var rawDuration = computedStyle.getPropertyValue('transition-duration');\n    /** @type {?} */\n    var rawDelay = computedStyle.getPropertyValue('transition-delay');\n    return parseCssTimeUnitsToMs(rawDuration) + parseCssTimeUnitsToMs(rawDelay);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    var from = clamp(fromIndex, array.length - 1);\n    /** @type {?} */\n    var to = clamp(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    var target = array[from];\n    /** @type {?} */\n    var delta = to < from ? -1 : 1;\n    for (var i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    var from = clamp(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    var to = clamp(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Counter used to generate unique ids for drop zones.\n  @type {?} */\nvar _uniqueIdCounter = 0;\n/** *\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n  @type {?} */\nvar DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nvar CdkDrop = /** @class */ (function () {\n    function CdkDrop(element, _dragDropRegistry) {\n        this.element = element;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDrop`.\n         */\n        this.id = \"cdk-drop-\" + _uniqueIdCounter++;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = function () { return true; };\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Whether an item in the container is being dragged.\n         */\n        this._dragging = false;\n        /**\n         * Cache of the dimensions of all the items and the sibling containers.\n         */\n        this._positionCache = {\n            items: /** @type {?} */ ([]),\n            siblings: /** @type {?} */ ([]),\n            self: /** @type {?} */ ({})\n        };\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: /** @type {?} */ (null), delta: 0 };\n    }\n    /**\n     * @return {?}\n     */\n    CdkDrop.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._dragDropRegistry.registerDropContainer(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkDrop.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._dragDropRegistry.removeDropContainer(this);\n    };\n    /** Starts dragging an item. */\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    CdkDrop.prototype.start = /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    function () {\n        this._dragging = true;\n        this._activeDraggables = this._draggables.toArray();\n        this._cachePositions();\n    };\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousContainer Container from which the item got dragged in.\n     */\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @return {?}\n     */\n    CdkDrop.prototype.drop = /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @return {?}\n     */\n    function (item, currentIndex, previousContainer) {\n        this._reset();\n        this.dropped.emit({\n            item: item,\n            currentIndex: currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            // TODO(crisbeto): reconsider whether to make this null if the containers are the same.\n            previousContainer: previousContainer\n        });\n    };\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     */\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    CdkDrop.prototype.enter = /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY) {\n        this.entered.emit({ item: item, container: this });\n        this.start();\n        /** @type {?} */\n        var newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        /** @type {?} */\n        var currentIndex = this._activeDraggables.indexOf(item);\n        /** @type {?} */\n        var newPositionReference = this._activeDraggables[newIndex];\n        /** @type {?} */\n        var placeholder = item.getPlaceholderElement();\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            this._activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            var element = newPositionReference.getRootElement(); /** @type {?} */\n            ((element.parentElement)).insertBefore(placeholder, element);\n            this._activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            this.element.nativeElement.appendChild(placeholder);\n            this._activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cachePositions();\n    };\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    CdkDrop.prototype.exit = /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    function (item) {\n        this._reset();\n        this.exited.emit({ item: item, container: this });\n    };\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    CdkDrop.prototype.getItemIndex = /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    function (item) {\n        return this._dragging ?\n            findIndex(this._positionCache.items, function (currentItem) { return currentItem.drag === item; }) :\n            this._draggables.toArray().indexOf(item);\n    };\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDeta Direction in which the pointer is moving along each axis.\n     */\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta\n     * @return {?}\n     */\n    CdkDrop.prototype._sortItem = /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta\n     * @return {?}\n     */\n    function (item, pointerX, pointerY, pointerDelta) {\n        var _this = this;\n        // Don't sort the item if it's out of range.\n        if (!this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        var siblings = this._positionCache.items;\n        /** @type {?} */\n        var newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        var isHorizontal = this.orientation === 'horizontal';\n        /** @type {?} */\n        var currentIndex = findIndex(siblings, function (currentItem) { return currentItem.drag === item; });\n        /** @type {?} */\n        var siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        var currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        var newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        var delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        /** @type {?} */\n        var itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        /** @type {?} */\n        var siblingOffset = isHorizontal ? currentPosition.width * delta :\n            currentPosition.height * delta;\n        /** @type {?} */\n        var oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        siblings.forEach(function (sibling, index) {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            var isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            var offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            var elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                elementToOffset.style.transform = \"translate3d(\" + sibling.offset + \"px, 0, 0)\";\n                _this._adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = \"translate3d(0, \" + sibling.offset + \"px, 0)\";\n                _this._adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        });\n    };\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    CdkDrop.prototype._getSiblingContainerFromPosition = /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, x, y) {\n        /** @type {?} */\n        var result = this._positionCache.siblings.find(function (_a) {\n            var clientRect = _a.clientRect;\n            var top = clientRect.top, bottom = clientRect.bottom, left = clientRect.left, right = clientRect.right;\n            return y >= top && y <= bottom && x >= left && x <= right;\n        });\n        return result && result.drop.enterPredicate(item, this) ? result.drop : null;\n    };\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @return {?}\n     */\n    CdkDrop.prototype._cachePositions = /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._positionCache.items = this._activeDraggables\n            .map(function (drag) {\n            /** @type {?} */\n            var elementToMeasure = _this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            /** @type {?} */\n            var clientRect = elementToMeasure.getBoundingClientRect();\n            return {\n                drag: drag,\n                offset: 0,\n                // We need to clone the `clientRect` here, because all the values on it are readonly\n                // and we need to be able to update them. Also we can't use a spread here, because\n                // the values on a `ClientRect` aren't own properties. See:\n                // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n                clientRect: {\n                    top: clientRect.top,\n                    right: clientRect.right,\n                    bottom: clientRect.bottom,\n                    left: clientRect.left,\n                    width: clientRect.width,\n                    height: clientRect.height\n                }\n            };\n        })\n            .sort(function (a, b) { return a.clientRect.top - b.clientRect.top; });\n        this._positionCache.siblings = coerceArray(this.connectedTo)\n            .map(function (drop) { return typeof drop === 'string' ? /** @type {?} */ ((_this._dragDropRegistry.getDropContainer(drop))) : drop; })\n            .filter(function (drop) { return drop && drop !== _this; })\n            .map(function (drop) { return ({ drop: drop, clientRect: drop.element.nativeElement.getBoundingClientRect() }); });\n        this._positionCache.self = this.element.nativeElement.getBoundingClientRect();\n    };\n    /**\n     * Resets the container to its initial state.\n     * @return {?}\n     */\n    CdkDrop.prototype._reset = /**\n     * Resets the container to its initial state.\n     * @return {?}\n     */\n    function () {\n        this._dragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach(function (item) { return item.getRootElement().style.transform = ''; });\n        this._activeDraggables = [];\n        this._positionCache.items = [];\n        this._positionCache.siblings = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n    };\n    /**\n     * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n     * @param {?} clientRect `ClientRect` that should be updated.\n     * @param {?} top Amount to add to the `top` position.\n     * @param {?} left Amount to add to the `left` position.\n     * @return {?}\n     */\n    CdkDrop.prototype._adjustClientRect = /**\n     * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n     * @param {?} clientRect `ClientRect` that should be updated.\n     * @param {?} top Amount to add to the `top` position.\n     * @param {?} left Amount to add to the `left` position.\n     * @return {?}\n     */\n    function (clientRect, top, left) {\n        clientRect.top += top;\n        clientRect.bottom = clientRect.top + clientRect.height;\n        clientRect.left += left;\n        clientRect.right = clientRect.left + clientRect.width;\n    };\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    CdkDrop.prototype._getItemIndexFromPointerPosition = /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY, delta) {\n        var _this = this;\n        /** @type {?} */\n        var isHorizontal = this.orientation === 'horizontal';\n        return findIndex(this._positionCache.items, function (_a, _, array) {\n            var drag = _a.drag, clientRect = _a.clientRect;\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                var direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === _this._previousSwap.drag && direction === _this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        });\n    };\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    CdkDrop.prototype._isPointerNearDropContainer = /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    function (pointerX, pointerY) {\n        var _a = this._positionCache.self, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        /** @type {?} */\n        var xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        var yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    };\n    CdkDrop.decorators = [\n        { type: Component, args: [{selector: 'cdk-drop',\n                    exportAs: 'cdkDrop',\n                    template: '<ng-content></ng-content>',\n                    encapsulation: ViewEncapsulation.None,\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    styles: [\".cdk-drag-preview{position:fixed;top:0;left:0;z-index:1000}.cdk-drag,.cdk-drag-handle{touch-action:none;-webkit-user-drag:none;-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}\"],\n                    providers: [\n                        { provide: CDK_DROP_CONTAINER, useExisting: CdkDrop },\n                    ],\n                    host: {\n                        'class': 'cdk-drop',\n                        '[id]': 'id',\n                        '[class.cdk-drop-dragging]': '_dragging'\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDrop.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: DragDropRegistry }\n    ]; };\n    CdkDrop.propDecorators = {\n        _draggables: [{ type: ContentChildren, args: [forwardRef(function () { return CdkDrag; }),] }],\n        connectedTo: [{ type: Input }],\n        data: [{ type: Input }],\n        orientation: [{ type: Input }],\n        id: [{ type: Input }],\n        lockAxis: [{ type: Input }],\n        enterPredicate: [{ type: Input }],\n        dropped: [{ type: Output }],\n        entered: [{ type: Output }],\n        exited: [{ type: Output }]\n    };\n    return CdkDrop;\n}());\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.find` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (var i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar DragDropModule = /** @class */ (function () {\n    function DragDropModule() {\n    }\n    DragDropModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        CdkDrop,\n                        CdkDrag,\n                        CdkDragHandle,\n                        CdkDragPreview,\n                        CdkDragPlaceholder,\n                    ],\n                    exports: [\n                        CdkDrop,\n                        CdkDrag,\n                        CdkDragHandle,\n                        CdkDragPreview,\n                        CdkDragPlaceholder,\n                    ],\n                },] },\n    ];\n    return DragDropModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { CdkDrop, CDK_DROP_CONTAINER, CdkDrag, CdkDragHandle, moveItemInArray, transferArrayItem, CdkDragPreview, CdkDragPlaceholder, DragDropModule, DragDropRegistry };\n//# sourceMappingURL=drag-drop.es5.js.map\n"],"sourceRoot":""}